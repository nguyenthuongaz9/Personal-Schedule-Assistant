from datetime import datetime, timedelta
import json
from typing import Dict, Any, List, Optional, Tuple
import logging
from models import ScheduleModel
import requests
import re

logger = logging.getLogger(__name__)

class PersonalAssistant:
    def __init__(self, config, db_manager, nlp_processor):
        self.config = config
        self.db = db_manager
        self.nlp = nlp_processor
        self.schedule_model = ScheduleModel(db_manager)
        self.ollama_url = getattr(config, 'OLLAMA_URL', 'http://localhost:11434')
        self.ollama_model = getattr(config, 'OLLAMA_MODEL', 'deepseek-r1')
    
    def process_message(self, user_id: int, message: str) -> Dict[str, Any]:
       
        logger.info(f"üéØ Processing message from user {user_id}: '{message}'")
        
        try:
        
            ollama_response = self._call_ollama_for_intent(message, user_id)
            
          
            if not ollama_response.get('success', True):
                return ollama_response
            
            logger.info(f"üîç Ollama raw response: {json.dumps(ollama_response, indent=2, ensure_ascii=False)}")
            
            
            if ollama_response.get('is_schedule_related', False):
              
                response = self._handle_schedule_with_ollama(user_id, ollama_response, message)
            else:
                
                response = {
                    'success': True,
                    'message': ollama_response.get('response', 'T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?'),
                    'type': 'general_conversation',
                    'is_ai_generated': True
                }
            
     
            logger.info(f"üì§ Final response: {response}")
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Critical error in process_message: {e}")
            return self._handle_critical_error(e, message)
    
    def _call_ollama_for_intent(self, message: str, user_id: int) -> Dict[str, Any]:
        
        try:
          
            existing_schedules = self._get_user_schedules_context(user_id)
            
           
            prompt = self._create_intent_analysis_prompt(message, user_id, existing_schedules)
            
       
            base_url = self.ollama_url.rstrip('/')
            if base_url.endswith('/api/generate'):
                base_url = base_url[:-13]
            url = f"{base_url}/api/generate"
            
            payload = {
                "model": self.ollama_model,
                "prompt": prompt,
                "stream": False,
                "options": {
                    "temperature": 0.3,
                    "top_p": 0.9,
                    "max_tokens": 1500  
                }
            }
            
            logger.info(f"üîó Calling Ollama at: {url}")
            logger.info(f"ü§ñ Using model: {self.ollama_model}")
            logger.info(f"‚è∞ Setting timeout: 300 seconds (5 minutes)")
            
            
            response = requests.post(url, json=payload, timeout=300)
            response.raise_for_status()
            
            result = response.json()
            generated_text = result.get('response', '').strip()
            
            if not generated_text:
                return {
                    'success': False,
                    'message': '‚ùå Ollama tr·∫£ v·ªÅ response tr·ªëng',
                    'type': 'ollama_error'
                }
            
            logger.info(f"‚úÖ Ollama response received: {len(generated_text)} characters")
            
        
            return self._parse_ollama_response(generated_text, message)
            
        except requests.exceptions.ConnectionError as e:
            logger.error(f"üîå Cannot connect to Ollama: {e}")
            return {
                'success': False,
                'message': '‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Ollama service. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi.',
                'type': 'connection_error'
            }
        except requests.exceptions.Timeout as e:
            logger.error(f"‚è∞ Ollama request timeout after 5 minutes: {e}")
            return {
                'success': False,
                'message': '‚è∞ Ollama x·ª≠ l√Ω qu√° l√¢u (h∆°n 5 ph√∫t). Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√¢u h·ªèi ng·∫Øn h∆°n.',
                'type': 'timeout_error'
            }
        except requests.exceptions.HTTPError as e:
            logger.error(f"üåê Ollama HTTP error: {e}")
            return {
                'success': False,
                'message': f'‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn Ollama: {e}',
                'type': 'http_error'
            }
        except Exception as e:
            logger.error(f"‚ùå Error calling Ollama for intent: {e}")
            return {
                'success': False,
                'message': f'‚ùå L·ªói khi x·ª≠ l√Ω y√™u c·∫ßu: {str(e)}',
                'type': 'unknown_error'
            }
    

    def _get_user_schedules_context(self, user_id: int) -> List[Dict[str, Any]]:
      
        try:
            schedules = self.schedule_model.get_user_schedules(user_id)
            context_schedules = []
            
            for schedule in schedules:
                try:
                  
                    if hasattr(schedule, '__dict__'):
                       
                        start_time = getattr(schedule, 'start_time', '')
                      
                        if hasattr(start_time, 'strftime'):
                            start_time = start_time.isoformat()
                        
                        schedule_info = {
                            'id': getattr(schedule, 'id', None),
                            'title': getattr(schedule, 'title', ''),
                            'start_time': start_time,
                            'category': getattr(schedule, 'category', 'general'),
                            'priority': getattr(schedule, 'priority', 'medium')
                        }
                    elif isinstance(schedule, dict):
                      
                        start_time = schedule.get('start_time', '')
                      
                        if hasattr(start_time, 'strftime'):
                            start_time = start_time.isoformat()
                        
                        schedule_info = {
                            'id': schedule.get('id'),
                            'title': schedule.get('title', ''),
                            'start_time': start_time,
                            'category': schedule.get('category', 'general'),
                            'priority': schedule.get('priority', 'medium')
                        }
                    else:
                    
                        continue
                    
                   
                    if schedule_info.get('id') and schedule_info.get('title'):
                        context_schedules.append(schedule_info)
                        
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error processing schedule: {e}")
                    continue
            
            logger.info(f"üìä Loaded {len(context_schedules)} schedules for context")
            return context_schedules
            
        except Exception as e:
            logger.error(f"‚ùå Error getting schedules context: {e}")
            return [] 
    
    def _create_intent_analysis_prompt(self, message: str, user_id: int, existing_schedules: List[Dict]) -> str:
       
        current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
      
        schedules_context = ""
        if existing_schedules:
            schedules_context = "L·ªäCH TR√åNH HI·ªÜN C√ì:\n"
            for i, schedule in enumerate(existing_schedules, 1):
                start_time = schedule['start_time']
                if 'T' in start_time:  # ISO format
                    start_time = datetime.fromisoformat(start_time.replace('Z', '+00:00')).strftime('%H:%M %d/%m/%Y')
                schedules_context += f"{i}. ID {schedule['id']}: {schedule['title']} - {start_time} ({schedule['category']})\n"
        
        return f"""B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh cho ·ª©ng d·ª•ng qu·∫£n l√Ω l·ªãch tr√¨nh. Ph√¢n t√≠ch tin nh·∫Øn ng∆∞·ªùi d√πng v√† x√°c ƒë·ªãnh intent.

QUAN TR·ªåNG: Lu√¥n tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON h·ª£p l·ªá.

QUY T·∫ÆC PH√ÇN T√çCH INTENT:
- "xem l·ªãch", "xem t·∫•t c·∫£ l·ªãch tr√¨nh", "l·ªãch tr√¨nh hi·ªán c√≥", "c√≥ nh·ªØng l·ªãch n√†o" -> intent: "query", query_scope: "all"
- "xem l·ªãch h√¥m nay", "h√¥m nay c√≥ g√¨" -> intent: "query", query_scope: "today"  
- "xem l·ªãch ng√†y mai", "mai c√≥ g√¨" -> intent: "query", query_scope: "tomorrow"
- "xem l·ªãch tu·∫ßn n√†y" -> intent: "query", query_scope: "week"
- "ƒë·∫∑t l·ªãch", "t·∫°o l·ªãch", "th√™m l·ªãch", "b√°o th·ª©c" -> intent: "schedule"
- "s·ª≠a l·ªãch", "ƒë·ªïi t√™n l·ªãch", "c·∫≠p nh·∫≠t l·ªãch" -> intent: "update"
- "x√≥a l·ªãch", "h·ªßy l·ªãch", "x√≥a b√°o th·ª©c" -> intent: "delete"
- C√°c c√¢u ch√†o h·ªèi, h·ªèi ƒë√°p th√¥ng th∆∞·ªùng -> intent: "conversation"

TH√îNG TIN CONTEXT:
- Th·ªùi gian hi·ªán t·∫°i: {current_time}
- User ID: {user_id}
{schedules_context}

ƒê·ªäNH D·∫†NG JSON B·∫ÆT BU·ªòC:
{{
    "is_schedule_related": boolean,
    "intent": "schedule|query|update|delete|conversation",
    "confidence": 0.0-1.0,
    "response": "string (ch·ªâ cho h·ªôi tho·∫°i th√¥ng th∆∞·ªùng)",
    "schedule_data": {{
        "title": "string",
        "description": "string", 
        "datetime": "YYYY-MM-DD HH:MM:SS",
        "category": "alarm|meeting|personal|general",
        "priority": "low|medium|high"
    }},
    "query_scope": "today|tomorrow|week|all",
    "schedule_id": number,
    "title_keyword": "string"
}}

V√ç D·ª§ JSON ƒê√öNG:
- "xem t·∫•t c·∫£ l·ªãch tr√¨nh" -> {{
  "is_schedule_related": true,
  "intent": "query", 
  "confidence": 0.9,
  "query_scope": "all"
}}

- "ƒë·∫∑t b√°o th·ª©c 7h s√°ng mai" -> {{
  "is_schedule_related": true,
  "intent": "schedule",
  "confidence": 0.9,
  "schedule_data": {{
    "title": "B√°o th·ª©c d·∫≠y",
    "datetime": "2025-12-02 07:00:00",
    "category": "alarm",
    "priority": "high"
  }}
}}

- "ch√†o b·∫°n" -> {{
  "is_schedule_related": false,
  "intent": "conversation", 
  "confidence": 0.8,
  "response": "Xin ch√†o! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?"
}}

Tin nh·∫Øn c·∫ßn ph√¢n t√≠ch: "{message}"

K·∫øt qu·∫£ JSON:"""
    
    def _parse_ollama_response(self, response_text: str, original_message: str) -> Dict[str, Any]:
        
        try:
            
            logger.info(f"üìù Ollama raw text: {response_text}")
            
           
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                logger.info(f"üîç Found JSON: {json_str}")
                
                parsed_data = json.loads(json_str)
                
                
                validated_data = self._validate_ollama_response(parsed_data, original_message)
                validated_data['success'] = True
                return validated_data
            else:
                
                logger.error(f"‚ùå No JSON found in Ollama response: {response_text}")
                return {
                    'success': False,
                    'message': '‚ùå Ollama tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá',
                    'type': 'format_error',
                    'raw_response': response_text[:500]  
                }
                
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå JSON parse error: {e}")
            logger.error(f"üìù Problematic JSON: {response_text}")
            return {
                'success': False,
                'message': '‚ùå L·ªói ph√¢n t√≠ch response t·ª´ Ollama',
                'type': 'parse_error',
                'raw_response': response_text[:500]
            }
        except Exception as e:
            logger.error(f"‚ùå Error parsing Ollama response: {e}")
            return {
                'success': False,
                'message': f'‚ùå L·ªói x·ª≠ l√Ω response: {str(e)}',
                'type': 'parse_error'
            }
    
    def _validate_ollama_response(self, data: Dict, original_message: str) -> Dict[str, Any]:
       
        if 'is_schedule_related' not in data:
            
            data['is_schedule_related'] = self._auto_detect_schedule_related(original_message)
        
        if 'intent' not in data:
            data['intent'] = 'conversation'
        
        if 'confidence' not in data:
            data['confidence'] = 0.7
        
       
        if data.get('intent') == 'query' and 'query_scope' not in data:
            data['query_scope'] = self._detect_query_scope(original_message)
        
        
        if data.get('is_schedule_related') and data.get('intent') == 'schedule':
            if 'schedule_data' not in data:
                data['schedule_data'] = {}
            
            schedule_data = data['schedule_data']
            
           
            if 'title' not in schedule_data:
                schedule_data['title'] = self._extract_fallback_title(original_message)
            
            if 'datetime' not in schedule_data:
                schedule_data['datetime'] = self._get_default_datetime()
            
            if 'category' not in schedule_data:
                schedule_data['category'] = 'general'
            
            if 'priority' not in schedule_data:
                schedule_data['priority'] = 'medium'
        
       
        data['original_message'] = original_message
        data['method'] = 'ollama_analysis'
        
        return data
    
    def _auto_detect_schedule_related(self, message: str) -> bool:
        
        message_lower = message.lower()
        schedule_keywords = ['l·ªãch', 'b√°o th·ª©c', 'nh·∫Øc', 'h·∫πn', 's·ª± ki·ªán', 'cu·ªôc h·ªçp', 'ƒë·∫∑t l·ªãch', 'xem l·ªãch', 'x√≥a l·ªãch', 's·ª≠a l·ªãch']
        return any(keyword in message_lower for keyword in schedule_keywords)
    
    def _detect_query_scope(self, message: str) -> str:
        
        message_lower = message.lower()
        
        if any(word in message_lower for word in ['mai', 'ng√†y mai']):
            return 'tomorrow'
        elif any(word in message_lower for word in ['h√¥m nay', 'h√¥m nay']):
            return 'today'
        elif any(word in message_lower for word in ['tu·∫ßn', 'tu·∫ßn n√†y']):
            return 'week'
        else:
            return 'all'
    
    def _extract_fallback_title(self, message: str) -> str:
       
        words = message.split()
        important_words = [word for word in words if len(word) > 2 and word not in 
                          ['ƒë·∫∑t', 't·∫°o', 'l·ªãch', 'b√°o', 'th·ª©c', 'nh·∫Øc', 'xem', 'x√≥a', 's·ª≠a', 't·∫•t', 'c·∫£', 'hi·ªán', 'c√≥']]
        
        if important_words:
            return ' '.join(important_words[:3])
        return "S·ª± ki·ªán m·ªõi"
    
    def _get_default_datetime(self) -> str:
        
        default_time = datetime.now() + timedelta(hours=1)
        return default_time.strftime('%Y-%m-%d %H:%M:%S')
    
    def _handle_schedule_with_ollama(self, user_id: int, ollama_data: Dict, original_message: str) -> Dict[str, Any]:
        
        intent = ollama_data.get('intent', 'conversation')
        
        logger.info(f"üîß Handling schedule intent: {intent}")
        logger.info(f"üìä Schedule data: {ollama_data}")
        
        try:
            if intent == 'schedule':
                return self._handle_schedule_creation(user_id, ollama_data)
            elif intent == 'query':
                return self._handle_schedule_query(user_id, ollama_data)
            elif intent == 'update':
                return self._handle_schedule_update(user_id, ollama_data)
            elif intent == 'delete':
                return self._handle_schedule_deletion(user_id, ollama_data)
            else:
                logger.error(f"‚ùå Unknown schedule intent: {intent}")
                return self._create_error_response('Kh√¥ng hi·ªÉu y√™u c·∫ßu v·ªÅ l·ªãch tr√¨nh')
                
        except Exception as e:
            logger.error(f"‚ùå Error handling schedule intent: {e}")
            return self._create_error_response('C√≥ l·ªói khi x·ª≠ l√Ω l·ªãch tr√¨nh')
    
    def _handle_schedule_creation(self, user_id: int, ollama_data: Dict) -> Dict[str, Any]:
        
        try:
            if not self._check_user_exists(user_id):
                return self._create_error_response('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i.')
            
            schedule_data = ollama_data.get('schedule_data', {})
            
           
            title = schedule_data.get('title', '').strip()
            datetime_str = schedule_data.get('datetime', '')
            
            if not title or title in ["", "S·ª± ki·ªán m·ªõi"]:
                return self._create_error_response('Vui l√≤ng cung c·∫•p ti√™u ƒë·ªÅ cho l·ªãch tr√¨nh')
            
            if not datetime_str:
                return self._create_error_response('Vui l√≤ng cung c·∫•p th·ªùi gian cho l·ªãch tr√¨nh')
            
           
            prepared_data = self._prepare_schedule_data(schedule_data)
            
            
            schedule_id = self.schedule_model.create_schedule(user_id, prepared_data)
            
           
            return self._create_schedule_success_response(prepared_data, schedule_id)
            
        except Exception as e:
            logger.error(f"‚ùå Error creating schedule: {e}")
            return self._create_error_response('C√≥ l·ªói khi t·∫°o l·ªãch tr√¨nh')
    
    def _prepare_schedule_data(self, schedule_data: Dict) -> Dict[str, Any]:
      
        title = schedule_data.get('title', '').strip()
        datetime_str = schedule_data.get('datetime', '')
        category = schedule_data.get('category', 'general')
        
        try:
            start_time = datetime.strptime(datetime_str, '%Y-%m-%d %H:%M:%S')
        except ValueError:
          
            start_time = datetime.now() + timedelta(hours=1)
        
      
        is_alarm = category == 'alarm'
        duration_minutes = 15 if is_alarm else 60
        end_time = start_time + timedelta(minutes=duration_minutes)
        
        return {
            'title': title,
            'description': schedule_data.get('description', ''),
            'start_time': start_time,
            'end_time': end_time,
            'priority': schedule_data.get('priority', 'high' if is_alarm else 'medium'),
            'category': category
        }
    
    def _create_schedule_success_response(self, schedule_data: Dict, schedule_id: int) -> Dict[str, Any]:
    
        start_time = schedule_data['start_time']
        formatted_time = start_time.strftime('%H:%M %d/%m/%Y')
        title = schedule_data['title']
        
        if schedule_data['category'] == 'alarm':
            message = f"‚è∞ ƒê√£ ƒë·∫∑t b√°o th·ª©c '{title}' v√†o l√∫c {formatted_time}"
            emoji = "‚è∞"
        else:
            message = f"‚úÖ ƒê√£ t·∫°o l·ªãch '{title}' v√†o l√∫c {formatted_time}"
            emoji = "‚úÖ"
        
        if schedule_data.get('description'):
            message += f"\nüìù Ghi ch√∫: {schedule_data['description']}"
        
        message += f"\nüÜî ID: {schedule_id}"
        
        return {
            'success': True,
            'message': message,
            'schedule_id': schedule_id,
            'type': 'schedule_created',
            'emoji': emoji,
            'created_schedule': {
                'id': schedule_id,
                'title': title,
                'start_time': start_time.strftime('%Y-%m-%d %H:%M:%S'),
                'category': schedule_data['category']
            }
        }
    
    def _handle_schedule_query(self, user_id: int, ollama_data: Dict) -> Dict[str, Any]:
       
        try:
            if not self._check_user_exists(user_id):
                return self._create_error_response('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i.')
            
            query_scope = ollama_data.get('query_scope', 'all')
            target_date = self._calculate_target_date(query_scope)
            
            schedules = self.schedule_model.get_user_schedules(user_id, target_date)
            
            if schedules:
                return self._create_schedule_list_response(schedules, query_scope)
            else:
                return self._create_empty_schedule_response(query_scope)
                
        except Exception as e:
            logger.error(f"‚ùå Error querying schedules: {e}")
            return self._create_error_response('C√≥ l·ªói khi truy v·∫•n l·ªãch tr√¨nh')
    
    def _calculate_target_date(self, query_scope: str) -> Optional[str]:
       
        now = datetime.now()
        
        if query_scope == 'today':
            return now.strftime('%Y-%m-%d')
        elif query_scope == 'tomorrow':
            return (now + timedelta(days=1)).strftime('%Y-%m-%d')
        elif query_scope == 'week':
            return None
        else:
            return None
    
    def _create_schedule_list_response(self, schedules: List, query_scope: str) -> Dict[str, Any]:
      
        schedule_list = []
        
        for schedule in schedules:
            schedule_info = self._extract_schedule_info(schedule)
            schedule_list.append(schedule_info)
        
        schedule_list.sort(key=lambda x: x['raw_start_time'])
        
        scope_messages = {
            'today': 'h√¥m nay',
            'tomorrow': 'ng√†y mai', 
            'week': 'tu·∫ßn n√†y',
            'all': 'hi·ªán c√≥'
        }
        
        scope_text = scope_messages.get(query_scope, '')
        message = f"üìÖ T√¨m th·∫•y {len(schedules)} l·ªãch tr√¨nh {scope_text}:"
        
        for i, s in enumerate(schedule_list, 1):
            message += f"\n{i}. **{s['title']}** - {s['start_time']} (ID: {s['id']})"
        
        message += f"\n\nüí° B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng ID ƒë·ªÉ x√≥a ho·∫∑c s·ª≠a l·ªãch tr√¨nh c·ª• th·ªÉ."
        
        return {
            'success': True,
            'message': message,
            'schedules': schedule_list,
            'type': 'schedule_list',
            'count': len(schedules),
            'schedule_ids': [s['id'] for s in schedule_list]
        }
    
    def _extract_schedule_info(self, schedule) -> Dict[str, Any]:
      
        if isinstance(schedule, dict):
            return {
                'id': schedule['id'],
                'title': schedule['title'],
                'start_time': self._format_datetime(schedule['start_time']),
                'end_time': self._format_datetime(schedule['end_time']),
                'priority': schedule.get('priority', 'medium'),
                'category': schedule.get('category', 'general'),
                'description': schedule.get('description', ''),
                'raw_start_time': self._get_raw_datetime(schedule['start_time']),
                'raw_end_time': self._get_raw_datetime(schedule['end_time'])
            }
        else:
            return {
                'id': schedule.id,
                'title': schedule.title,
                'start_time': self._format_datetime(schedule.start_time),
                'end_time': self._format_datetime(schedule.end_time),
                'priority': schedule.priority,
                'category': schedule.category,
                'description': schedule.description,
                'raw_start_time': self._get_raw_datetime(schedule.start_time),
                'raw_end_time': self._get_raw_datetime(schedule.end_time)
            }
    
    def _format_datetime(self, dt) -> str:
       
        if hasattr(dt, 'strftime'):
            return dt.strftime('%H:%M %d/%m/%Y')
        elif isinstance(dt, str):
            try:
                parsed_dt = datetime.strptime(dt, '%Y-%m-%d %H:%M:%S')
                return parsed_dt.strftime('%H:%M %d/%m/%Y')
            except ValueError:
                return dt
        else:
            return str(dt)
    
    def _get_raw_datetime(self, dt) -> str:
      
        if hasattr(dt, 'strftime'):
            return dt.strftime('%Y-%m-%d %H:%M:%S')
        elif isinstance(dt, str):
            return dt
        else:
            return datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    def _create_empty_schedule_response(self, query_scope: str) -> Dict[str, Any]:
       
        scope_messages = {
            'today': 'cho h√¥m nay',
            'tomorrow': 'cho ng√†y mai',
            'week': 'trong tu·∫ßn n√†y',
            'all': 'hi·ªán c√≥'
        }
        
        scope_text = scope_messages.get(query_scope, '')
        message = f"üìÖ Kh√¥ng c√≥ l·ªãch tr√¨nh n√†o {scope_text}"
        
        return {
            'success': True,
            'message': message,
            'schedules': [],
            'type': 'no_schedules',
            'schedule_ids': []
        }
    
    def _handle_schedule_update(self, user_id: int, ollama_data: Dict) -> Dict[str, Any]:
       
        try:
            if not self._check_user_exists(user_id):
                return self._create_error_response('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i.')
            
            schedule_id = ollama_data.get('schedule_id')
            schedule_data = ollama_data.get('schedule_data', {})
            new_title = schedule_data.get('title', '').strip()
            
            if not schedule_id:
                return self._create_error_response('Vui l√≤ng cung c·∫•p ID l·ªãch tr√¨nh c·∫ßn s·ª≠a')
            
            if not new_title:
                return self._create_error_response('Vui l√≤ng cung c·∫•p ti√™u ƒë·ªÅ m·ªõi')
            
           
            update_data = {'title': new_title}
            success = self.schedule_model.update_schedule(schedule_id, update_data)
            
            if success:
                return {
                    'success': True,
                    'message': f'‚úÖ ƒê√£ s·ª≠a l·ªãch tr√¨nh ID {schedule_id} th√†nh "{new_title}"',
                    'schedule_id': schedule_id,
                    'type': 'schedule_updated'
                }
            else:
                return self._create_error_response('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t l·ªãch tr√¨nh')
                
        except Exception as e:
            logger.error(f"‚ùå Error updating schedule: {e}")
            return self._create_error_response('C√≥ l·ªói khi s·ª≠a l·ªãch tr√¨nh')
    
    def _handle_schedule_deletion(self, user_id: int, ollama_data: Dict) -> Dict[str, Any]:
       
        try:
            if not self._check_user_exists(user_id):
                return self._create_error_response('Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i.')
            
            schedule_id = ollama_data.get('schedule_id')
            title_keyword = ollama_data.get('title_keyword', '').strip()
            
            if schedule_id:
                
                success = self.schedule_model.delete_schedule(schedule_id)
                if success:
                    return {
                        'success': True,
                        'message': f'‚úÖ ƒê√£ x√≥a l·ªãch tr√¨nh ID {schedule_id}',
                        'schedule_id': schedule_id,
                        'type': 'schedule_deleted'
                    }
                else:
                    return self._create_error_response('Kh√¥ng t√¨m th·∫•y l·ªãch tr√¨nh ƒë·ªÉ x√≥a')
            
            elif title_keyword:
              
                all_schedules = self.schedule_model.get_user_schedules(user_id)
                matching_schedules = []
                
                for schedule in all_schedules:
                    schedule_title = self._get_schedule_title(schedule)
                    if title_keyword.lower() in schedule_title.lower():
                        matching_schedules.append(schedule)
                
                if len(matching_schedules) == 1:
                    schedule_to_delete = matching_schedules[0]
                    schedule_id_to_delete = self._get_schedule_id(schedule_to_delete)
                    
                    success = self.schedule_model.delete_schedule(schedule_id_to_delete)
                    if success:
                        return {
                            'success': True,
                            'message': f'‚úÖ ƒê√£ x√≥a l·ªãch tr√¨nh "{self._get_schedule_title(schedule_to_delete)}"',
                            'schedule_id': schedule_id_to_delete,
                            'type': 'schedule_deleted'
                        }
                elif len(matching_schedules) > 1:
                    return self._handle_multiple_matches(matching_schedules, "x√≥a")
                else:
                    return self._create_error_response(f'Kh√¥ng t√¨m th·∫•y l·ªãch tr√¨nh v·ªõi t·ª´ kh√≥a "{title_keyword}"')
            
            else:
                return self._create_error_response('Vui l√≤ng cung c·∫•p ID ho·∫∑c t√™n l·ªãch tr√¨nh c·∫ßn x√≥a')
                
        except Exception as e:
            logger.error(f"‚ùå Error deleting schedule: {e}")
            return self._create_error_response('C√≥ l·ªói khi x√≥a l·ªãch tr√¨nh')
    
    def _get_schedule_id(self, schedule) -> Optional[int]:
       
        try:
            if hasattr(schedule, '__dict__'):
                return getattr(schedule, 'id', None)
            elif isinstance(schedule, dict):
                return schedule.get('id')
            else:
                return None
        except:
            return None 
    

    def _get_schedule_title(self, schedule) -> str:
      
        try:
            if hasattr(schedule, '__dict__'):
                return getattr(schedule, 'title', '')
            elif isinstance(schedule, dict):
                return schedule.get('title', '')
            else:
                return ''
        except:
            return '' 
    
    def _handle_multiple_matches(self, schedules: List, action: str) -> Dict[str, Any]:
       
        schedule_list = []
        for schedule in schedules:
            schedule_info = {
                'id': self._get_schedule_id(schedule),
                'title': self._get_schedule_title(schedule),
                'start_time': self._format_datetime(self._get_schedule_start_time_obj(schedule)),
                'category': self._get_schedule_category(schedule)
            }
            schedule_list.append(schedule_info)
        
        schedule_list.sort(key=lambda x: x['id'])
        
        message = f"üîç T√¨m th·∫•y {len(schedules)} l·ªãch tr√¨nh ph√π h·ª£p:\n\n"
        for i, s in enumerate(schedule_list, 1):
            message += f"{i}. ID {s['id']}: {s['title']} - {s['start_time']}\n"
        
        message += f"\nüí° H√£y n√≥i '{action} l·ªãch tr√¨nh [ID]' ƒë·ªÉ ch·ªçn."
        
        return {
            'success': False,
            'message': message,
            'schedules': schedule_list,
            'type': 'multiple_matches',
            'count': len(schedules)
        }
    

    def _get_schedule_start_time_obj(self, schedule):
        
        try:
            if hasattr(schedule, '__dict__'):
                return getattr(schedule, 'start_time', None)
            elif isinstance(schedule, dict):
                return schedule.get('start_time')
            else:
                return None
        except:
            return None 
    

    def _get_schedule_category(self, schedule) -> str:
    
        try:
            if hasattr(schedule, '__dict__'):
                return getattr(schedule, 'category', 'general')
            elif isinstance(schedule, dict):
                return schedule.get('category', 'general')
            else:
                return 'general'
        except:
            return 'general'
    
    def _handle_critical_error(self, error: Exception, message: str) -> Dict[str, Any]:
       
        logger.error(f"üö® Critical error processing message '{message}': {error}")
        
        return {
            'success': False,
            'message': 'üòµ ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá h·ªó tr·ª£.',
            'type': 'critical_error'
        }
    
    def _create_error_response(self, message: str) -> Dict[str, Any]:
        
        return {
            'success': False,
            'message': message,
            'type': 'error'
        }
    
    def _check_user_exists(self, user_id: int) -> bool:
      
        try:
            query = "SELECT id FROM users WHERE id = %s"
            result = self.db.execute_query(query, (user_id,), fetch=True)
            return len(result) > 0
        except Exception as e:
            logger.error(f"‚ùå Error checking user: {e}")
            return False
    
    
    def _make_json_safe(self, obj):
        
        if isinstance(obj, dict):
            return {k: self._make_json_safe(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._make_json_safe(item) for item in obj]
        elif isinstance(obj, datetime):
            return obj.isoformat()
        else:
            return obj